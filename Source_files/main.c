#include <stdio.h>
#include <stdlib.h>
#include <string.h>     // memset, strlen
#include "socket_use.h" // IF_ANET, SOCK_STREAM, ...
#include <getopt.h>     // getopt, optarg, ...
#include <stdbool.h>    // bool

#define ARGV_PORT_IDX           1
#define ARGV_MAX_CONN_NUM_IDX   2
#define MIN_CONN_NUM            1
#define MAX_CONN_NUM            3
#define MIN_PORT_VALUE          49152
#define MAX_PORT_VALUE          65535

#define MAX_ERROR_MSG_LEN   100

#define ERR_ARG_PARSING_FAILED  -1

#define P_OPT_INDEX 0
#define C_OPT_INDEX 1
#define T_OPT_INDEX 2

#define P_OPT_DETAIL "Port"
#define C_OPT_DETAIL "Maximum number of connections"
#define T_OPT_DETAIL "Just a boolean test option"

#define HAS_VALUE_OFF   false
#define HAS_VALUE_ON    true
#define MAX_DETAIL_LEN  100
#define COLON_CHAR      ':'

#define OPT_SUCCESS                  0
#define ERR_OPT_ALREADY_VALUED      -1
#define ERR_OPT_NEEDS_VALUE         -2
#define ERR_OPT_VALUE_OUT_OF_BOUNDS -3
#define ERR_OPT_DOES_NOT_EXIST      -4

typedef struct 
{
    char    opt_char;
    char    detail[MAX_DETAIL_LEN];
    bool    has_value;
    int     min_value;
    int     max_value;
    int     assigned_value;

}option_description;

option_description opt_desc[] =
{
    {
        .opt_char   = 'p'           ,
        .detail     = P_OPT_DETAIL  ,
        .has_value  = HAS_VALUE_ON  ,
        .min_value  = MIN_PORT_VALUE,
        .max_value  = MAX_PORT_VALUE,
    },
    {
        .opt_char   = 'c',
        .detail     = C_OPT_DETAIL,
        .has_value  = HAS_VALUE_ON,
        .min_value  = MIN_CONN_NUM,
        .max_value  = MAX_CONN_NUM
    },
    {
        .opt_char   = 't'           ,
        .detail     = T_OPT_DETAIL  ,
        .has_value  = HAS_VALUE_OFF ,
    }
};

/// @brief Generates a string including the options that are meant to be inputed properly formatted.
/// @param option_descr Array of option_description structs. Each one includes information about a parameter.
/// @param option_descr_size Size of the previous input parameter.
/// @param opt_short Short form of command line arguments, properly formatted.
void PreParseOptions(option_description* option_descr, int option_descr_size, char* opt_short)
{
    char option_short[option_descr_size * 2 + 1];
    memset(option_short, 0, sizeof(option_short));
    
    for(int i = 0; i < option_descr_size; i++)
    {
        option_short[strlen(option_short)] = option_descr[i].opt_char;

        if(option_descr[i].has_value == HAS_VALUE_ON)
        {
            option_short[strlen(option_short)] = COLON_CHAR;
        }
    }

    strcpy(opt_short, option_short);
}

/// @brief Parse all the command line parameters that are passed to the current program.
/// @param argc Argument count.
/// @param argv Argument vector.
/// @param option_descr Options description.
/// @param option_descr_size Options description strut instance size.
/// @param opt_short Short form for program's options. Autogenerated by PreParseOptions.
/// @return 0 if success, < 0 otherwise.
int ParseArguments(int argc, char** argv, option_description* option_descr, int option_descr_size, char* opt_short)
{
    int option;
    int curr_opt;

    while((option = getopt(argc, argv, opt_short)) != -1)
    {
        for(curr_opt = 0; curr_opt < option_descr_size; curr_opt++)
        {
            // Check if the option exists within option_descr. 
            if(option == option_descr[curr_opt].opt_char)
            {
                // If so, checki if the option has already been assigned a value.
                if(option_descr[curr_opt].assigned_value != 0)
                {
                    printf("Value already assigned to the current parameter (%s).\r\n", option_descr[curr_opt].detail);
                    return ERR_OPT_ALREADY_VALUED;
                }
                
                // Check if the option is binary, or if any value requires to be provided instead.
                if(option_descr[curr_opt].has_value == HAS_VALUE_OFF)
                {
                    option_descr[curr_opt].assigned_value = true;
                    break;
                }

                // If the option is not binary (i.e., it has to be given a value), then check if any value is provided.
                // It may also happen that the option's value is assumed to be the following parameter's first character (-p).
                if( (optarg == NULL) || (optarg[0] == '-') )
                {
                    printf("A value should be passed to the current parameter (%s).\r\n", option_descr[curr_opt].detail);
                    return ERR_OPT_NEEDS_VALUE;
                }
                
                // Get integer value from provided option value.
                int option_int = atoi(optarg);

                // Check if the option value is out of boundaries or not.
                if(option_int < option_descr[curr_opt].min_value || option_int > option_descr[curr_opt].max_value)
                {
                    printf("Provided option value is out of boundaries (%s) [%d-%d]\r\n.",  option_descr[curr_opt].detail   ,
                                                                                            option_descr[curr_opt].min_value,
                                                                                            option_descr[curr_opt].max_value);
                    return ERR_OPT_VALUE_OUT_OF_BOUNDS;
                }

                // Assign the given value to the current option.
                option_descr[curr_opt].assigned_value = option_int;
                break;
            }
        }
        
        // If (iterator value) == (option_descr_size), it means that the option has noot been found.
        if(curr_opt == option_descr_size)
        {
            printf("Option %c does not exist.\r\n", option);
            return ERR_OPT_DOES_NOT_EXIST;
        }
    }

    return OPT_SUCCESS;
}

/// @brief Calls PreparseOptions and ParseArguments. Public function.
/// @param argc Argument count.
/// @param argv Argument vector.
/// @param option_descr Options description.
/// @param option_descr_size Options description strut instance size.
/// @param opt_short Short form for program's options. Autogenerated by PreParseOptions.
/// @return 0 if success, < 0 otherwise.
int GetOptions(int argc, char** argv, option_description* option_descr, int option_descr_size, char* opt_short)
{
    PreParseOptions(option_descr, option_descr_size, opt_short);
    return ParseArguments(argc, argv, option_descr, option_descr_size, opt_short);
}

/*
@brief Main function. Program's entry point.
*/
int main(int argc, char** argv)
{
    int opt_desc_size = sizeof(opt_desc) / sizeof(opt_desc[0]);
    char options_short[opt_desc_size * 2 + 1];
    // PreParseOptions(opt_desc, opt_desc_size, options_short);

    // int parse_arguments = ParseArguments(argc, argv, opt_desc, opt_desc_size, options_short);
    int parse_arguments = GetOptions(argc, argv, opt_desc, opt_desc_size, options_short);
    if(parse_arguments < 0)
    {
        printf("Arguments parsing failed!\r\n");
        return ERR_ARG_PARSING_FAILED;
    }
    
    int server_port = opt_desc[P_OPT_INDEX].assigned_value;
    int max_conn_num = opt_desc[C_OPT_INDEX].assigned_value;
    bool test_bool_option = opt_desc[T_OPT_INDEX].assigned_value;

    int socket_desc = CreateSocketDescriptor(AF_INET, SOCK_STREAM, IPPROTO_IP);

    int socket_options = SocketOptions(socket_desc, 1, 1, 1, 5, 5);

    struct sockaddr_in server = PrepareForBinding(AF_INET, INADDR_ANY, server_port);

    int bind_socket = BindSocket(socket_desc, server);

    int listen = SocketListen(socket_desc, max_conn_num);

    int new_socket = SocketAccept(socket_desc);

    int read = SocketRead(new_socket);

    int close = CloseSocket(new_socket);

    return 0;
}
